import { App, SlackCommandMiddlewareArgs, SlackActionMiddlewareArgs, SlackViewMiddlewareArgs } from '@slack/bolt';
import { DailyService } from '../../services/communication/DailyService';
import { ConditionTracker } from '../../services/communication/ConditionTracker';
import { UserSyncService } from '../../services/core/UserSyncService';
import { logger } from '../../utils/logger';
import { WeatherCondition } from '../../models/DailyReport';

export class DailyHandler {
  private dailyService: DailyService;
  private conditionTracker: ConditionTracker;
  private userSyncService: UserSyncService;

  constructor() {
    this.dailyService = new DailyService();
    this.conditionTracker = new ConditionTracker();
    this.userSyncService = new UserSyncService();
  }

  register(app: App): void {
    // Slash command for daily report
    app.command('/daily', this.handleDailyCommand.bind(this));
    
    // Action handlers
    app.action(/^daily_condition_/, this.handleConditionSelect.bind(this));
    
    // View submission handlers
    app.view('daily_report_modal', this.handleDailyReportModal.bind(this));
    
    // Shortcut for quick daily report
    app.shortcut('daily_report', this.handleDailyShortcut.bind(this));
  }

  private async handleDailyCommand(args: SlackCommandMiddlewareArgs): Promise<void> {
    const { command, ack, client, respond } = args;
    
    try {
      await ack();
      
      const userId = command.user_id;
      const subcommand = command.text.trim().toLowerCase();

      switch (subcommand) {
        case '':
        case 'create':
          await this.showDailyReportModal(client, command.trigger_id, userId);
          break;
        case 'today':
          await this.showTodayReports(respond, userId);
          break;
        case 'my':
          await this.showMyReports(respond, userId);
          break;
        case 'summary':
          await this.showDailySummary(respond);
          break;
        case 'trend':
          await this.showMyTrend(respond, userId);
          break;
        case 'team':
          await this.showTeamSummary(respond);
          break;
        case 'insights':
          await this.showInsights(respond);
          break;
        case 'weekly':
          await this.showWeeklySummary(respond);
          break;
        default:
          await respond({
            text: '‰ΩøÁî®ÊñπÊ≥ï:\n' +
                  '‚Ä¢ `/daily` - Êó•Â†±„Çí‰ΩúÊàê\n' +
                  '‚Ä¢ `/daily today` - ‰ªäÊó•„ÅÆÊó•Â†±‰∏ÄË¶ß\n' +
                  '‚Ä¢ `/daily my` - Ëá™ÂàÜ„ÅÆÊó•Â†±Â±•Ê≠¥\n' +
                  '‚Ä¢ `/daily summary` - ‰ªäÊó•„ÅÆ„ÉÅ„Éº„É†Áä∂Ê≥Å\n' +
                  '‚Ä¢ `/daily trend` - Ëá™ÂàÜ„ÅÆ„Ç≥„É≥„Éá„Ç£„Ç∑„Éß„É≥Êé®Áßª\n' +
                  '‚Ä¢ `/daily team` - „ÉÅ„Éº„É†Ë©≥Á¥∞„Çµ„Éû„É™„Éº\n' +
                  '‚Ä¢ `/daily weekly` - ÈÄ±Èñì„Çµ„Éû„É™„Éº\n' +
                  '‚Ä¢ `/daily insights` - „ÉÅ„Éº„É†ÂàÜÊûê',
            response_type: 'ephemeral'
          });
      }
    } catch (error) {
      logger.error('Error handling daily command:', error);
      await respond({
        text: '„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ',
        response_type: 'ephemeral'
      });
    }
  }

  private async handleDailyShortcut(args: SlackActionMiddlewareArgs): Promise<void> {
    const { shortcut, ack, client } = args;
    
    try {
      await ack();
      
      if (shortcut.type === 'shortcut') {
        await this.showDailyReportModal(client, shortcut.trigger_id, shortcut.user.id);
      }
    } catch (error) {
      logger.error('Error handling daily shortcut:', error);
    }
  }

  private async showDailyReportModal(client: any, triggerId: string, userId: string): Promise<void> {
    try {
      // Sync user first
      await this.userSyncService.syncUser(userId);
      
      // Get existing report for today
      const existingReport = await this.dailyService.getTodayReport(userId);
      
      const modal = {
        type: 'modal',
        callback_id: 'daily_report_modal',
        title: {
          type: 'plain_text',
          text: 'Êó•Â†±‰ΩúÊàê'
        },
        submit: {
          type: 'plain_text',
          text: 'ÈÄÅ‰ø°'
        },
        close: {
          type: 'plain_text',
          text: '„Ç≠„É£„É≥„Çª„É´'
        },
        blocks: [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: '‰ªäÊó•„ÅÆ„Ç≥„É≥„Éá„Ç£„Ç∑„Éß„É≥„Å®ÈÄ≤Êçó„ÇíÊïô„Åà„Å¶„Åè„Å†„Åï„ÅÑ üìù'
            }
          },
          {
            type: 'divider'
          },
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: '*‰ªäÊó•„ÅÆ„Ç≥„É≥„Éá„Ç£„Ç∑„Éß„É≥* ‚òÄÔ∏è'
            }
          },
          {
            type: 'actions',
            block_id: 'condition_block',
            elements: this.createConditionButtons(existingReport?.condition)
          },
          {
            type: 'input',
            block_id: 'progress_block',
            element: {
              type: 'plain_text_input',
              action_id: 'progress_input',
              placeholder: {
                type: 'plain_text',
                text: '‰ªäÊó•„ÅÆÈÄ≤Êçó„ÇÑÂèñ„ÇäÁµÑ„Çì„Å†„Åì„Å®„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ'
              },
              initial_value: existingReport?.progress || '',
              multiline: true
            },
            label: {
              type: 'plain_text',
              text: 'ÈÄ≤Êçó'
            },
            optional: true
          },
          {
            type: 'input',
            block_id: 'notes_block',
            element: {
              type: 'plain_text_input',
              action_id: 'notes_input',
              placeholder: {
                type: 'plain_text',
                text: 'ËøΩÂä†„ÅÆ„É°„É¢„ÇÑÊÑüÊÉ≥„Åå„ÅÇ„Çå„Å∞ÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ'
              },
              initial_value: existingReport?.notes || '',
              multiline: true
            },
            label: {
              type: 'plain_text',
              text: '„É°„É¢'
            },
            optional: true
          }
        ],
        private_metadata: JSON.stringify({
          userId,
          existingReportId: existingReport?.id
        })
      };

      await client.views.open({
        trigger_id: triggerId,
        view: modal
      });
    } catch (error) {
      logger.error('Error showing daily report modal:', error);
      throw error;
    }
  }

  private createConditionButtons(selectedCondition?: string): any[] {
    const conditions: { value: WeatherCondition; emoji: string; text: string }[] = [
      { value: 'sunny', emoji: '‚òÄÔ∏è', text: 'Êô¥„Çå' },
      { value: 'cloudy', emoji: '‚òÅÔ∏è', text: 'Êõá„Çä' },
      { value: 'rainy', emoji: 'üåßÔ∏è', text: 'Èõ®' },
      { value: 'stormy', emoji: '‚õàÔ∏è', text: 'Âµê' },
      { value: 'snowy', emoji: '‚ùÑÔ∏è', text: 'Èõ™' },
      { value: 'foggy', emoji: 'üå´Ô∏è', text: 'Èúß' }
    ];

    return conditions.map(condition => ({
      type: 'button',
      action_id: `daily_condition_${condition.value}`,
      text: {
        type: 'plain_text',
        text: `${condition.emoji} ${condition.text}`
      },
      value: condition.value,
      style: selectedCondition === condition.value ? 'primary' : undefined
    }));
  }

  private async handleConditionSelect(args: SlackActionMiddlewareArgs): Promise<void> {
    const { action, ack, body, client } = args;
    
    try {
      await ack();
      
      if (action.type === 'button' && body.type === 'block_actions') {
        const selectedCondition = action.value;
        
        // Update the modal with selected condition
        const view = body.view;
        if (view) {
          const updatedBlocks = view.blocks.map((block: any) => {
            if (block.block_id === 'condition_block') {
              return {
                ...block,
                elements: this.createConditionButtons(selectedCondition)
              };
            }
            return block;
          });

          await client.views.update({
            view_id: view.id,
            view: {
              ...view,
              blocks: updatedBlocks,
              private_metadata: JSON.stringify({
                ...JSON.parse(view.private_metadata || '{}'),
                selectedCondition
              })
            }
          });
        }
      }
    } catch (error) {
      logger.error('Error handling condition select:', error);
    }
  }

  private async handleDailyReportModal(args: SlackViewMiddlewareArgs): Promise<void> {
    const { ack, view, body, client } = args;
    
    try {
      const metadata = JSON.parse(view.private_metadata || '{}');
      const { userId, selectedCondition, existingReportId } = metadata;
      
      const values = view.state.values;
      const progress = values.progress_block?.progress_input?.value || '';
      const notes = values.notes_block?.notes_input?.value || '';

      if (!selectedCondition) {
        await ack({
          response_action: 'errors',
          errors: {
            condition_block: '„Ç≥„É≥„Éá„Ç£„Ç∑„Éß„É≥„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ'
          }
        });
        return;
      }

      await ack();

      // Create or update daily report
      const reportData = {
        userId,
        condition: selectedCondition,
        progress: progress || undefined,
        notes: notes || undefined
      };

      const report = await this.dailyService.createDailyReport(reportData);
      
      // Get user info for display
      const userInfo = await client.users.info({ user: userId });
      const userName = userInfo.user?.real_name || userInfo.user?.name || 'Unknown User';
      
      // Format and send message
      const message = this.dailyService.formatDailyReportMessage(report, userName);
      
      // Send to user as confirmation
      await client.chat.postMessage({
        channel: userId,
        text: 'Êó•Â†±„ÇíÊäïÁ®ø„Åó„Åæ„Åó„ÅüÔºÅ',
        blocks: [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: '‚úÖ Êó•Â†±„ÇíÊäïÁ®ø„Åó„Åæ„Åó„ÅüÔºÅ'
            }
          },
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: message
            }
          }
        ]
      });

      logger.info(`Daily report submitted by user ${userId}`, {
        reportId: report.id,
        condition: report.condition
      });
    } catch (error) {
      logger.error('Error handling daily report modal:', error);
      await ack({
        response_action: 'errors',
        errors: {
          progress_block: '„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ'
        }
      });
    }
  }

  private async showTodayReports(respond: any, requesterId: string): Promise<void> {
    try {
      const reports = await this.dailyService.getTodayReports();
      
      if (reports.length === 0) {
        await respond({
          text: '‰ªäÊó•„ÅÆÊó•Â†±„ÅØ„Åæ„Å†„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ',
          response_type: 'ephemeral'
        });
        return;
      }

      const summary = this.dailyService.generateDailyReportSummary(reports);
      
      await respond({
        text: summary,
        response_type: 'ephemeral'
      });
    } catch (error) {
      logger.error('Error showing today reports:', error);
      await respond({
        text: '„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ',
        response_type: 'ephemeral'
      });
    }
  }

  private async showMyReports(respond: any, userId: string): Promise<void> {
    try {
      const reports = await this.dailyService.getUserReports(userId, 7); // Last 7 reports
      
      if (reports.length === 0) {
        await respond({
          text: '„Åæ„Å†Êó•Â†±„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ`/daily` „ÅßÊó•Â†±„Çí‰ΩúÊàê„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜÔºÅ',
          response_type: 'ephemeral'
        });
        return;
      }

      let message = 'üìã **„ÅÇ„Å™„Åü„ÅÆÊúÄËøë„ÅÆÊó•Â†±**\n\n';
      
      reports.forEach(report => {
        const emoji = this.dailyService.getWeatherEmoji(report.condition);
        const date = report.date.toLocaleDateString('ja-JP');
        message += `${emoji} ${date} - ${this.dailyService.getConditionDescription(report.condition)}\n`;
        
        if (report.progress) {
          message += `   üìù ${report.progress.substring(0, 100)}${report.progress.length > 100 ? '...' : ''}\n`;
        }
        message += '\n';
      });

      await respond({
        text: message,
        response_type: 'ephemeral'
      });
    } catch (error) {
      logger.error('Error showing my reports:', error);
      await respond({
        text: '„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ',
        response_type: 'ephemeral'
      });
    }
  }

  private async showDailySummary(respond: any): Promise<void> {
    try {
      const reports = await this.dailyService.getTodayReports();
      const summary = this.dailyService.generateDailyReportSummary(reports);
      
      await respond({
        text: summary,
        response_type: 'in_channel'
      });
    } catch (error) {
      logger.error('Error showing daily summary:', error);
      await respond({
        text: '„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ',
        response_type: 'ephemeral'
      });
    }
  }

  private async showMyTrend(respond: any, userId: string): Promise<void> {
    try {
      const trend = await this.conditionTracker.getConditionHistory(userId, 14); // Last 14 days
      
      if (trend.conditions.length === 0) {
        await respond({
          text: '„Åæ„Å†ÂçÅÂàÜ„Å™Êó•Â†±„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇÁ∂ôÁ∂ö„Åó„Å¶Êó•Â†±„ÇíÊäïÁ®ø„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºÅ',
          response_type: 'ephemeral'
        });
        return;
      }

      const message = this.conditionTracker.formatConditionTrend(trend);
      
      await respond({
        text: message,
        response_type: 'ephemeral'
      });
    } catch (error) {
      logger.error('Error showing my trend:', error);
      await respond({
        text: '„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ',
        response_type: 'ephemeral'
      });
    }
  }

  private async showTeamSummary(respond: any): Promise<void> {
    try {
      const today = new Date();
      const summary = await this.conditionTracker.getTeamConditionSummary(today);
      const message = this.conditionTracker.formatTeamSummary(summary);
      
      await respond({
        text: message,
        response_type: 'ephemeral'
      });
    } catch (error) {
      logger.error('Error showing team summary:', error);
      await respond({
        text: '„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ',
        response_type: 'ephemeral'
      });
    }
  }

  private async showInsights(respond: any): Promise<void> {
    try {
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - 30); // Last 30 days

      const insights = await this.conditionTracker.getConditionInsights(startDate, endDate);
      
      let message = 'üìà **„ÉÅ„Éº„É†ÂàÜÊûê„É¨„Éù„Éº„Éà** (ÈÅéÂéª30Êó•Èñì)\n\n';
      
      message += `**ÂèÇÂä†Áéá:** ${insights.averageParticipation.toFixed(1)}%\n\n`;
      
      message += '**ÊúÄ„ÇÇÊ¥ªÁô∫„Å™„É°„É≥„Éê„Éº:**\n';
      insights.mostActiveUsers.slice(0, 5).forEach((user, index) => {
        message += `${index + 1}. ${user.userName} (${user.reportCount}Âõû)\n`;
      });
      
      message += '\n**„Ç≥„É≥„Éá„Ç£„Ç∑„Éß„É≥ÂàÜÂ∏É:**\n';
      Object.entries(insights.conditionDistribution)
        .sort(([,a], [,b]) => b - a)
        .forEach(([condition, count]) => {
          const emoji = this.getConditionEmoji(condition);
          message += `${emoji} ${condition}: ${count}Âõû\n`;
        });

      if (insights.consistentReporters.length > 0) {
        message += `\n**Á∂ôÁ∂öÂ†±ÂëäËÄÖ (80%‰ª•‰∏ä):** ${insights.consistentReporters.slice(0, 5).join(', ')}\n`;
      }

      if (insights.improvingUsers.length > 0) {
        message += `\nüìà **ÊîπÂñÑÂÇæÂêë:** ${insights.improvingUsers.slice(0, 5).join(', ')}\n`;
      }

      if (insights.decliningUsers.length > 0) {
        message += `\nüìâ **Ê≥®ÊÑè„ÅåÂøÖË¶Å:** ${insights.decliningUsers.slice(0, 3).join(', ')}\n`;
      }
      
      await respond({
        text: message,
        response_type: 'ephemeral'
      });
    } catch (error) {
      logger.error('Error showing insights:', error);
      await respond({
        text: '„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ',
        response_type: 'ephemeral'
      });
    }
  }

  private async showWeeklySummary(respond: any): Promise<void> {
    try {
      const today = new Date();
      const startOfWeek = new Date(today);
      startOfWeek.setDate(today.getDate() - today.getDay()); // Start of current week (Sunday)

      const weeklyStats = await this.conditionTracker.getWeeklyConditionStats(startOfWeek);
      
      let message = 'üìÖ **ÈÄ±Èñì„Çµ„Éû„É™„Éº**\n\n';
      
      const days = ['Êó•', 'Êúà', 'ÁÅ´', 'Ê∞¥', 'Êú®', 'Èáë', 'Âúü'];
      
      Object.entries(weeklyStats).forEach(([date, summary]) => {
        const dayOfWeek = new Date(date).getDay();
        const dayName = days[dayOfWeek];
        
        message += `**${dayName}ÊõúÊó• (${date}):**\n`;
        message += `  ÂèÇÂä†: ${summary.totalReports}Âêç (${summary.participationRate.toFixed(1)}%)\n`;
        
        if (summary.totalReports > 0) {
          const topCondition = Object.entries(summary.conditionBreakdown)
            .sort(([,a], [,b]) => b - a)[0];
          
          if (topCondition) {
            const emoji = this.getConditionEmoji(topCondition[0]);
            message += `  ‰∏ª„Å™Áä∂Ê≥Å: ${emoji} ${topCondition[1]}Âêç\n`;
          }
        }
        message += '\n';
      });

      await respond({
        text: message,
        response_type: 'ephemeral'
      });
    } catch (error) {
      logger.error('Error showing weekly summary:', error);
      await respond({
        text: '„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ',
        response_type: 'ephemeral'
      });
    }
  }

  private getConditionEmoji(condition: string): string {
    const emojiMap: Record<string, string> = {
      'sunny': '‚òÄÔ∏è',
      'cloudy': '‚òÅÔ∏è',
      'rainy': 'üåßÔ∏è',
      'stormy': '‚õàÔ∏è',
      'snowy': '‚ùÑÔ∏è',
      'foggy': 'üå´Ô∏è'
    };

    return emojiMap[condition] || 'üå§Ô∏è';
  }
}